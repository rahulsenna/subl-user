     # List of some scopes (just in case..):
# 
# source.actionscript.2  source.dosbatch          source.ini.editorconfig
# source.applescript     source.dot               source.jade
# source.asp             source.erlang            source.java
# source.c               source.gdb.session       source.java-props
# source.c++             source.gdbregs           source.jl
# source.camlp4.ocaml    source.git               source.js
# source.clojure         source.go                source.js.rails
# source.cmake           source.gradle            source.json
# source.coffee          source.groovy            source.json.bower
# source.cs              source.gruntfile.coffee  source.json.npm
# source.css             source.gruntfile.js      source.jsx
# source.d               source.gulpfile.coffee   source.less
# source.diff            source.gulpfile.js       source.lisp
# source.disasm          source.haskell           source.lua
# source.dockerfile      source.ini               source.makefile
# 
# source.matlab          source.regexp
# source.nant-build      source.regexp.python
# source.objc            source.ruby
# source.objc++          source.ruby.rails
# source.ocaml           source.rust
# source.ocamllex        source.sass
# source.ocamlyacc       source.scala
# source.pascal          source.scss
# source.perl            source.shell
# source.php             source.sql
# source.procfile        source.sql.ruby
# source.puppet          source.stylus
# source.pyjade          source.swift
# source.python          source.tcl
# source.qml             source.ts
# source.r               source.yaml
# source.r-console

# Structure of fix
# 
# {scope}[ {scope}[...]]: - one or multiple (separated by whitespace) scopes
#   - cmd    - trigger string
#     target - regex pattern
#     fix    - template

# Available variables
# 
# $-->    - indent
# $cursor - cursor position
# $0      - whole matched string
# $X      - RegEx group indexed from 1

# Some examples:

# C C++


# Python
source.python:
  # Print
  - cmd: "pr"
    line: true
    target: ".+"
    fix: |
      print("$0: ", $0)

  # If
  - cmd: "if"
    line: true
    target: ".+"
    fix: |
      if $0:
      $-->

  # If not
  - cmd: "ifn"
    line: true
    target: ".+"
    fix: |
      if !$0:
      $-->

  # Read file
  - cmd: "rf"
    line: true
    target: "(.+?)\\s?[=\\s]\\s?(.+)"
    fix: |
      with open($2) as f:
      $-->$1 = f.read()

  # Write file
  - cmd: "wf"
    line: true
    target: "(.+?)\\s?[=\\s]\\s?(.+)"
    fix: |
      with open($1, "w") as f:
      $-->f.write($2)


# C, C++
source.c++ source.c:

  - cmd: "beg"
    line: false
    target: "(\\w+)"
    fix: |
      $0.begin(), $0.end()$cursor

  # Accumulate
  - cmd: "acc"
    line: true
    target: ".+"
    fix: |
      auto sum = accumulate($0.begin(), $0.end(), 0$cursor);



  # STL Algorithms Functions generated by chatgpt

  # All Of
  - cmd: "all_of"
    line: true
    target: ".+"
    fix: |
      bool result = all_of($0.begin(), $0.end(), $1$cursor);


  # Any Of
  - cmd: "any_of"
    line: true
    target: ".+"
    fix: |
      bool result = any_of($0.begin(), $0.end(), $1$cursor);


  # None Of
  - cmd: "none_of"
    line: true
    target: ".+"
    fix: |
      bool result = none_of($0.begin(), $0.end(), $1$cursor);


  # For Each
  - cmd: "for_each"
    line: true
    target: ".+"
    fix: |
      for_each($0.begin(), $0.end(), [&](auto&& $1$cursor) {
        $2
      });


  # Find
  - cmd: "find"
    line: true
    target: ".+"
    fix: |
      auto it = find($0.begin(), $0.end(), $1$cursor);


  # Find If
  - cmd: "find_if"
    line: true
    target: ".+"
    fix: |
      auto it = find_if($0.begin(), $0.end(), [&](const auto& $1$cursor) {
        $2
      });


  # Find If Not
  - cmd: "find_if_not"
    line: true
    target: ".+"
    fix: |
      auto it = find_if_not($0.begin(), $0.end(), [&](const auto& $1$cursor) {
        $2
      });


  # Count
  - cmd: "count"
    line: true
    target: ".+"
    fix: |
      auto count = count($0.begin(), $0.end(), $1$cursor);


  # Count If
  - cmd: "count_if"
    line: true
    target: ".+"
    fix: |
      auto count = count_if($0.begin(), $0.end(), [&](const auto& $1$cursor) {
        $2
      });


  # Mismatch
  - cmd: "mismatch"
    line: true
    target: ".+"
    fix: |
      auto mismatch = mismatch($0.begin(), $0.end(), $1$cursor);









  # Sort
  - cmd: "srt"
    line: true
    target: ".+"
    fix: |
      sort($0.begin(), $0.end());$cursor

  # Sort Descending
  - cmd: "srtd"
    line: true
    target: ".+"
    fix: |
      sort($0.begin(), $0.end(), greater<int>());



  # For Each
  - cmd: "fore"
    line: true
    target: ".+"
    fix: |
      for (auto &e: $0)
      {
      $-->$cursor
      }



  - cmd: "nn"
    line: false
    target: "(\\w+)\\s(\\w+)"
    fix: |
      !$1 fuck$cursor $2
  # If
  - cmd: "if"
    line: true
    target: ".+"
    fix: |
      if ($0)
      { 
      $-->$cursor
      }

  - cmd: "el"
    line: true
    target: ".+"
    fix: |
      else
      {
      $-->$0
      }$cursor

  # Inlined If
  - cmd: "ifi"
    line: true
    target: ".+"
    fix: |
      if ($0) 

  # If not
  - cmd: "ifn"
    line: true
    target: ".+"
    fix: |
      if (!$0) 
      {
      $-->$cursor
      }


  - cmd: "for"
    line: true
    target: ".+"
    fix: |
      for (size_t i = 0; i < $0; ++i)
      {
      $-->$cursor 
      }

  - cmd: "forj"
    line: true
    target: "(.+)\\s(.+)"
    fix: |
      for (size_t $2 = 0; $2 < $1; ++$2)
      {
      $-->$cursor 
      }

  # Equality
  - cmd: "eq"
    line: true
    target: "(.+)\\s(.+)"
    fix: |
      if ($1 == $2)
      {
      $-->$cursor
      }

  # InEquality
  - cmd: "neq"
    line: true
    target: "(.+)\\s(.+)"
    fix: |
      if ($1 != $2)
      {
      $-->$cursor
      }


  - cmd: "str"
    line: true
    target: ".+"
    fix: |
      typedef struct
      {
      $-->$cursor
      } $0;



  - cmd: "not"
    line: false
    target: "w+"
    fix: |
      !$0$cursor

  - cmd: "cst"
    line: false
    target: "(\\w+)\\.(\\w+)"
    fix: |
      (($2)$1)$cursor


  - cmd: "ret"
    line: false
    target: "([^\\s]+)"
    fix: |
      return($0);$cursor

  - cmd: "prd"
    line: false
    target: "([^\\s]+)"
    fix: |
      printf("$0: %d$cursor\n", $0);


  - cmd: "prs"
    line: false
    target: "([^\\s]+)"
    fix: |
      printf("$0: %s$cursor\n", $0);


  - cmd: "pr"
    line: true
    target: ".+"
    fix: |
      printf("$0\n");



  - cmd: "si"
    line: false
    target: "(\\w+)"
    fix: |
      sizeof($1)$cursor


  - cmd: "co"
    line: true
    target: ".+"
    fix: |
      std::cout << "$0: " << $0 << '\n';$cursor


  - cmd: "main"
    line: true
    target: ".+"
    fix: |
      #include <bits/stdc++.h>
      using namespace std;


      int main()
      {
      $-->$cursor
      $-->return(0);

      }

  - cmd: "mainst"
    line: true
    target: ".+"
    fix: |
      #include <stdio.h>
      #include <stdlib.h>

      int main()
      {
      $-->printf("Hello, Sailor!\n");$cursor
      $-->return(0);

      }


# Javascript, Typescript
source.js source.ts:
  - cmd: "ret"
    line: false
    target: "(\\w+)"
    fix: |
      return($0)$cursor;

  # If
  - cmd: "if"
    line: true
    target: ".+"
    fix: |
      if ($0)
      {
      $-->$cursor
      }
  # Inlined If
  - cmd: "ifi"
    line: true
    target: ".+"
    fix: |
      if ($0) 
  # If not
  - cmd: "ifn"
    line: true
    target: ".+"
    fix: |
      if (!$0)
      {
      $-->$cursor
      }
  # Equality
  - cmd: "eq"
    line: true
    target: "(.+)\\s(.+)"
    fix: |
      if ($1 === $2)
      {
      $-->$cursor
      }
  # NotEquality
  - cmd: "neq"
    line: true
    target: "(.+)\\s(.+)"
    fix: |
      if ($1 !== $2)
      {
      $-->$cursor
      }
  # Function
  - cmd: "fun"
    line: true
    target: "([a-zA-Z0-9_]+)\\s?(.*)"
    fix: |
      function $1($2)
      {
      $-->$cursor
      }
  # Log
  - cmd: "lg"
    line: true
    target: ".+"
    fix: |
      console.log("$0$cursor: ", $0)
  - cmd: "llg"
    line: true
    target: ".+"
    fix: |
      console.log("$0");
  - cmd: "prd"
    line: true
    target: ".+"
    fix: |
      console.log("$0$cursor: ", $0)
  # Fetch
  - cmd: "fetch"
    line: true
    target: ".+"
    fix: |
      fetch($0)
      $-->.then(res => {
      $-->$-->$cursor
      $-->})
      $-->.catch(err => {
      $-->$-->
      $-->})

# ... and so on